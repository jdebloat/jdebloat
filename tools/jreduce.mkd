# JReduce

JReduce is a tool that uses a variant of delta-debugging to reduce the
classes of a project given a property. The tool was originally build to
reduce the bytecode that caused bugs in decompilers. We categorized a
bug as any set of classes with no external dependencies, was not able to
decompile and then compile again. The goal was therefore to find the
smallest set of classes, that still had all their dependencies. 

In this case, we use the test suite as the property that we want to 
preserve. Then we reduce the number of classes to the smallest possible 
where the tests still succeed.

## Technical Details

JReduce works by calculating a dependency graph from classes to other
classes. We create the graph by creating an edge from a class to another
if the first class mentions the second class.

Using the graph, we calculate all the strongly connected components
(SCC). If we include one of the classes in an SCC, all
classes in the SCC needs to be included. This means that we can reduce
the program, by reducing this list of SCCs. 

It is rare that a program runs classes outside the SCC that contains the
main class, but can happens if the program uses reflection. We have
therefore developed a new reduction technique called *Binary Reduction*,
which can quickly search the list for the few SCC needed to satisfy the
predicate.

In our tool, it is also possible to provide a set of core classes. The
core classes should not be removed. If a SCC contains a class from
the core, it will not be removed. In our case, we set the test-cases as
a core.

## Usage

To run JReduce on the benchmarks of this project, first install the
tool by running `make jreduce-install`. 

Then run `make jreduce` and the output can be found in the
`output/jreduce` folder.

You can also run the tool on your own benchmarks. Either use 
the `script/runjreduce.sh` script or you can run JReduce directly:

```
jreduce -v -o output --cp test.jar -t app.jar -c @classes-in-core.txt \
  <runpredicate> <args..>
```

Where `runpredicate.sh` is a script that takes a reduced `app.jar` and
has exit code 0 if the predicate succeeded. In the `runjreduce.sh`
script we use `runtest.sh` with the `test.jar` and `test.classes.txt`.

In the case you want to be adventures; consult the help notes:

```
Usage: jreduce [-v] [-q] [-D|--log-depth ARG] [-c|--core CORE] [--cp CLASSPATH]
               [--stdlib] [--jre JRE] (-t|--target FILE) (-o|--output FILE)
               [-R|--reducer ARG] [-W|--work-folder ARG] [-K|--keep-folders]
               [-E|--exit-code CODE] [--stdout] [--stderr] [-T|--timelimit SECS]
               CMD [ARG..]
  A command line tool for reducing java programs.

Available options:
  -v                       make it more verbose.
  -q                       make it more quiet.
  -D,--log-depth ARG       set the log depth. (default: -1)
  -c,--core CORE           the core classes to not reduce.
  --cp CLASSPATH           the library classpath, of things not reduced.
  --stdlib                 load the standard library.
  --jre JRE                the location of the stdlib.
  -t,--target FILE         the path to the jar or folder to reduce.
  -o,--output FILE         the path output folder.
  -R,--reducer ARG         the reducing algorithm to use. (default: Binary)
  -W,--work-folder ARG     the work folder.
  -K,--keep-folders        keep the work folders after use?
  -E,--exit-code CODE      preserve exit-code (default: 0)
  --stdout                 preserve stdout.
  --stderr                 preserve stderr.
  -T,--timelimit SECS      the maximum number of seconds to run the process,
                           negative means no timelimit. (default: -1.0)
  CMD                      the command to run
  ARG..                    arguments to the command.
  -h,--help                Show this help text
```
